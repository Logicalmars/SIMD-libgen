
# Copyright (c) 2011, Hua Huang and Robert D. Cameron.
# Licensed under the Academic Free License 3.0. 

#configure file

from IDISAOperations import AllOperations 

#SIMD instruction sets
MMX = "MMX"
SSE = "SSE"
SSE2 = "SSE2"
SSE3 = "SSE3"
SSSE3 = "SSSE3"
SSE4 = "SSE4"
SSE4_a = "SSE4_a"
SSE4_1 = "SSE4_1"
SSE4_2 = "SSE4_2"
NEON = "NEON"
AVX = "AVX"
AVX2 = "AVX2"
ALL = "ALL"
SSE_SERIES = [SSE, SSE2, SSE3, SSSE3, SSE4_1, SSE4_2]
AVX_SERIES = [AVX, AVX2]

#Languages and architectures
Language_C = "C"
Language_CPP = "CPP"
#LLVM = 'LLVM'
UnknownLang = "UNKNOWN_LANG"
UnknownArch = "UNKNOWN_ARCH"
DefaultLang = Language_CPP
DefaultArch = SSE2

Body_Declaration = "declaration"
Body_Implementation = "implementation"
Body_All = "all"

Macro_Idisa128_Hpp = r'''
#if defined USE_SSE3
#include "idisa_cpp/idisa_sse3.cpp"
#elif defined USE_SSSE3
#include "idisa_cpp/idisa_ssse3.cpp"
#elif defined USE_SSE4_1
#include "idisa_cpp/idisa_sse4_1.cpp"
#elif defined USE_SSE4_2
#include "idisa_cpp/idisa_sse4_2.cpp"
#elif defined USE_NEON
#include "idisa_cpp/idisa_neon.cpp"
#else
#include "idisa_cpp/idisa_sse2.cpp"
#endif
'''

Macro_Idisa256_Hpp = r'''
#if defined USE_AVX
#include "idisa_cpp/idisa_avx.cpp"
#else
#include "idisa_cpp/idisa_avx2.cpp"
#endif
'''

Macro_Idisa_Hpp = r'''
#ifndef BLOCK_SIZE
#define BLOCK_SIZE 128
#endif

#if (BLOCK_SIZE == 128)
#include "idisa128.hpp"
typedef bitblock128_t BitBlock;
template <uint32_t fw>
class simd: public simd128<fw>
{
};
template <uint32_t fw>
class hsimd: public hsimd128<fw>
{
};
template <uint32_t fw>
class esimd: public esimd128<fw>
{
};
template <uint32_t fw>
class mvmd: public mvmd128<fw>
{
};
class bitblock: public bitblock128
{
};
#endif

#if (BLOCK_SIZE == 256)
#include "idisa256.hpp"
typedef bitblock256_t BitBlock;
template <uint32_t fw>
class simd: public simd256<fw>
{
};
template <uint32_t fw>
class hsimd: public hsimd256<fw>
{
};
template <uint32_t fw>
class esimd: public esimd256<fw>
{
};
template <uint32_t fw>
class mvmd: public mvmd256<fw>
{
};
class bitblock: public bitblock256
{
};
#endif
'''

#Register sizes for different instruction sets
RegisterSize = {MMX:64, SSE:128, SSE2:128, SSE3:128, SSSE3:128, SSE4:128, SSE4_a:128, SSE4_1:128, SSE4_2:128, NEON:128, AVX:256, AVX2:256}

#Instruction set library
InstructionSetLibrary = {MMX:"mmintrin.h", SSE:"xmmintrin.h", SSE2:"emmintrin.h", SSE3:"pmmintrin.h",\
	SSSE3:"tmmintrin.h", SSE4_a:"ammintrin.h", SSE4_1:"smmintrin.h", SSE4_2:"smmintrin.h", NEON:"arm_neon.h", \
	AVX:"immintrin.h", AVX2:"immintrin.h"}
#Imports
ExtraImports = {AVX:["idisa_sse2.cpp"], AVX2:["emmintrin.h"]}

#SIMD types in C/C++ for different instruction sets
SIMD_type = {MMX:"__m64", SSE:"__m128i", SSE2:"__m128i", SSE3:"__m128i", SSSE3:"__m128i", SSE4_a:"__m128i", SSE4_1:"__m128i", SSE4_2:"__m128i", NEON:"uint64x2_t", \
	AVX:"__m256", AVX2:"__m256i"}

Bitblock_type = {MMX:"bitblock64_t", SSE:"bitblock128_t", SSE2:"bitblock128_t", SSE3:"bitblock128_t", SSSE3:"bitblock128_t", SSE4_1:"bitblock128_t", SSE4_2:"bitblock128_t",
				NEON:"bitblock128_t", AVX:"bitblock256_t", AVX2:"bitblock256_t"}

Load_type = {MMX:"bitblock64_t*", SSE:"bitblock128_t*", SSE2:"bitblock128_t*", SSE3:"bitblock128_t*", SSSE3:"bitblock128_t*", SSE4_1:"bitblock128_t*", SSE4_2:"bitblock128_t*",
			NEON:"uint64_t const*", AVX:"bitblock256_t*", AVX2:"bitblock256_t*"}

Store_type = {MMX:"bitblock64_t*", SSE:"bitblock128_t*", SSE2:"bitblock128_t*", SSE3:"bitblock128_t*", SSSE3:"bitblock128_t*", SSE4_1:"bitblock128_t*", SSE4_2:"bitblock128_t*",
			NEON:"uint64_t*", AVX:"bitblock256_t*", AVX2:"bitblock256_t*"}

AVXBuiltInVecWrapper = "AVXBuiltInVecWrapper"
AVXBuiltInHorWrapper = "AVXBuiltInHorWrapper"
avx_select_lo128 = "avx_select_lo128"
avx_select_hi128 = "avx_select_hi128"
avx_general_combine256 = "avx_general_combine256"

cppCopyrightNotice = r'''
/* Copyright (c) 2011, Hua Huang and Robert D. Cameron.
   Licensed under the Academic Free License 3.0.
   This file is generated by the IDISA+ generator;
   modifications should be made only by changing the
   generator configuration and data files. */

'''
