
# Copyright (c) 2011, Hua Huang and Robert D. Cameron.
# Licensed under the Academic Free License 3.0. 

#the main program of library tester
import sys
import os
#import logging

#import GenerateCppTesting
import GenerateCppTests
import TesterUtility
from TesterUtility import configure, OptParser
from TesterUtility import Operation
import CalculateResult
import ParseIdisaDB
import AssemblyInstructionCount

def WriteTestingData(fileName, data):
	fileOut = open(fileName, "w")
	for aList in data:
		if type(aList) == list:
			for v in aList:
				fileOut.write(str(v) + " ")
		else:
			fileOut.write(str(aList) + " ")
		fileOut.write("\n")
	fileOut.close()
	
def WriteResults(fileName, data=[]):
	fileOut = open(fileName, "w")
	for v in data:
		fileOut.write(str(v) + "\n")
	fileOut.close()

def GetGCCCommand(arch):
	if arch == "SSE2":
		return "g++ -msse2 -o "
	elif arch == "SSE3":
		return "g++ -msse3 -o"
	elif arch == "SSSE3":
		return "g++ -mssse3 -o "
	elif arch == "SSE4_1":
		return "g++ -msse4.1 -o"
	elif arch == "SSE4_2":
		return "g++ -msse4.2 -o"
	elif arch == configure.AVX:
		return "g++ -mavx -o"

def ReadContentAsOneLine(fileName):
	fin = open(fileName, 'r')
	content = fin.readlines()
	fin.close()
	for i in range(len(content)):
		content[i] = content[i].replace("\n", "")
		content[i] = content[i].replace("\r", "")
	return content

def GetOpAndFw(op_fw):
	sz = len(op_fw)
	for i in range(sz-1, -1, -1):
		if op_fw[i] == "_":
			fw = op_fw[i+1:]
			op = op_fw.replace("_"+fw, "")
			return (op, fw)
	return ("", "")

def CheckCorrectness(testingData):
	cwd = os.getcwd()
	outputFolder = cwd + "/output/"
	outputTempFolder = cwd + "/output_temp/"
	
	standardAns = {}
	ourAns = {}

	for op_fw in testingData:
		standardAns[op_fw] = ReadContentAsOneLine(outputFolder  + op_fw + ".out")
		ourAns[op_fw] = ReadContentAsOneLine(outputTempFolder  + op_fw + ".out")
	
	finalResult = []
	for op_fw in testingData:
		if op_fw not in ourAns:
			#print oop + " is not in the current answer..."
			#print op_fw + " is not in the current answer..."
			finalResult.append(op_fw + " is not in the current answer...")
		elif op_fw not in standardAns:
			#print oop + " is not in the standard answer..."
			#print op_fw + " is not in the standard answer..."
			finalResult.append(op_fw + " is not in the standard answer...")
		else:
			#print standardAns[oop]
			#print ourAns[oop]
			if standardAns[op_fw] == ourAns[op_fw]:
				#print op_fw + " is OK!"
				pass
			else:
				#print op_fw + " is NOT OK!"
				finalResult.append(op_fw + " is NOT OK!")
	
	finalResult.sort()
	for err in finalResult:
		print err

def Main(idisa_file, options):
	
	arch = idisa_file.replace("idisa_", "").upper()

	if arch not in configure.RegisterSize:
		print "cann't support this arch", arch
		sys.exit()
	
	validOperations = ParseIdisaDB.Parse("idisa_" + arch.lower() + ".db")
	definedOperations = Operation.LoadDefinedOperations(configure.AllOperations, arch)
	#GenerateCppTesting.Generate(arch + "_" + "test" + ".cpp", arch, validOperations)
	
	if options.instruction_count:
		#AssemblyInstructionCount.MakeCpps(arch, definedOperations, validOperations)
		AssemblyInstructionCount.GetInstructionCount(arch, definedOperations, validOperations)
		sys.exit()
	
	testingData = GenerateCppTests.MakeTestdata(arch, definedOperations, validOperations)
	#print testingData
	
	if options.test_option == "neon_test_data":
		print "You have specified neon_test_data option!"
		print arch + "_test" + " has been executed successfully!"
		CheckCorrectness(testingData)
		sys.exit()
	
	cppText = GenerateCppTests.MakeCppText(arch, definedOperations, validOperations, testingData, options)
	
	GenerateCppTests.WriteCppText(arch, arch+"_test.cpp", cppText)
	
	#write all testing data on the disk
	inputDir = os.getcwd() + "/input/"
	for op_fw in testingData:
		WriteTestingData(inputDir + op_fw + ".in", testingData[op_fw])
	
	#write all results of the testing data on the disk
	outputDir = os.getcwd() + "/output/"
	outPutTmpDir = os.getcwd() + "/output_temp/"
	regSize = configure.RegisterSize[arch]
	for op_fw in testingData:
		(op, fw) = GetOpAndFw(op_fw)
		#print op_fw, op, fw
		
		WriteResults(outputDir + op_fw + ".out", CalculateResult.GetResult(definedOperations[op][int(fw)], testingData[op_fw], regSize))
	
	#raw_input("finish writing testing results!\n")
	
	if options.test_option != "neon_gen_data":
		#execute external shell commands to get output generated by library routines
		os.system(GetGCCCommand(arch) + arch + "_test" + " " + arch + "_test.cpp")
		exeReturn = os.system("./" + arch + "_test")
		if exeReturn != 0:
			print "Something wrong with the xxx_test.cpp! Can not execute the xxx_test correctly!"
		else:
			print arch + "_test" + " has been executed successfully!"
			CheckCorrectness(testingData)

if __name__ == "__main__":
	
	optParser = OptParser.GetOptParser() 
	options, args = optParser.parse_args(sys.argv[1:])
	
	if options.use_tester:
		os.system("cp ../Library_Generator/" + options.idisa_file + ".*" + " ./")
		Main(options.idisa_file, options)
	else:
		print "idisa doesn't know what to do..."
